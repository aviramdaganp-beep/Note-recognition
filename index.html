<!doctype html>
<html lang="he">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>iPhone Pitch Detector</title>
  <style>
    body { font-family: system-ui, Arial; margin: 0; padding: 18px; }
    button { width: 100%; padding: 16px; font-size: 20px; border: 0; border-radius: 14px; font-weight: 800; }
    .card { margin-top: 14px; padding: 16px; border: 1px solid #e6e6e6; border-radius: 14px; }
    .note { font-size: 52px; font-weight: 900; line-height: 1.1; }
    .muted { color: #666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .row { margin-top: 10px; }
    .hint { margin-top: 10px; font-size: 14px; color: #666; }
  </style>
</head>
<body>
  <h2 style="margin:0 0 6px 0;">×–×™×”×•×™ ×¦×œ×™×œ ××”××™×§×¨×•×¤×•×Ÿ (××™×™×¤×•×Ÿ)</h2>
  <div class="muted">×—×™×™×‘ HTTPS. ×¢×“×™×£ ×œ×¤×ª×•×— ×‘-Safari. ×œ×—×¥ â€œ×”×ª×—×œâ€.</div>

  <button id="btn">ğŸ¤ ×”×ª×—×œ</button>

  <div class="card">
    <div class="note" id="note">â€”</div>
    <div class="row">Hz: <span class="mono" id="freq">â€”</span></div>
    <div class="row">Cents: <span class="mono" id="cents">â€”</span></div>

    <div class="row">Clarity: <span class="mono" id="clarity">â€”</span></div>
    <div class="row">RMS: <span class="mono" id="rms">â€”</span></div>

    <div class="row muted">Status: <span class="mono" id="status">×œ× ×¤×¢×™×œ</span></div>
    <div class="hint">×˜×™×¤: ×ª×• ×‘×•×“×“ ×•×™×¦×™×‘ (×©×¨×™×§×” / â€œ××”×”â€ / ×¤×¡× ×ª×¨ ×ª×• ×™×—×™×“). ××•×–×™×§×”/××§×•×¨×“×™× ×™×§×¤×™×¦×•.</div>
  </div>

  <!-- iOS hint -->
  <audio playsinline></audio>

<script>
(() => {
  const btn = document.getElementById("btn");
  const noteEl = document.getElementById("note");
  const freqEl = document.getElementById("freq");
  const centsEl = document.getElementById("cents");
  const clarityEl = document.getElementById("clarity");
  const rmsEl = document.getElementById("rms");
  const statusEl = document.getElementById("status");

  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

  // iOS: 2048/4096 ×¢×•×‘×“, 2048 ×™×•×ª×¨ ××”×™×¨. ×× ×™×© ××™-×™×¦×™×‘×•×ª ×‘×§×•×œ × ××•×š, × ×¡×” 4096.
  const FFT_SIZE = 2048;
  const buf = new Float32Array(FFT_SIZE);

  let audioCtx = null;
  let analyser = null;
  let stream = null;
  let rafId = null;
  let running = false;

  // smoothing for displayed frequency (to reduce flicker)
  let smoothedFreq = null;
  const SMOOTH_ALPHA = 0.25; // higher = smoother

  // thresholds
  const RMS_GATE = 0.005;     // ignore near-silence
  const CLARITY_GATE = 0.25;  // be forgiving on iOS
  const MAX_JUMP_RATIO = 2.0; // ignore sudden >25% jumps (often glitches)

  btn.addEventListener("click", async () => {
    if (running) return stop();

    try {
      if (!window.isSecureContext) {
        statusEl.textContent = "×¦×¨×™×š HTTPS (×œ× ×¢×•×‘×“ ×-file://).";
        return;
      }

      statusEl.textContent = "××‘×§×© ×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿâ€¦";

      // Keep it minimal on iOS (advanced constraints can break pitch)
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();

      const src = audioCtx.createMediaStreamSource(stream);

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = FFT_SIZE;
      analyser.smoothingTimeConstant = 0.15; // small smoothing

      src.connect(analyser);

      running = true;
      btn.textContent = "â¹ ×¢×¦×•×¨";
      statusEl.textContent = "×××–×™×Ÿâ€¦";
      loop();
    } catch (e) {
      statusEl.textContent = "×©×’×™××”: " + (e?.name ? `${e.name}: ` : "") + (e?.message || e);
    }
  });

  function loop() {
    analyser.getFloatTimeDomainData(buf);

    const res = detectPitchAutocorr(buf, audioCtx.sampleRate);
    const freq = res.freq;
    const clarity = res.clarity;
    const rms = res.rms;

    rmsEl.textContent = rms.toFixed(4);
    clarityEl.textContent = clarity.toFixed(2);

    if (freq && rms >= RMS_GATE && clarity >= CLARITY_GATE) {
      // Reject crazy jumps (often false detections)
      if (smoothedFreq && (freq / smoothedFreq > MAX_JUMP_RATIO || smoothedFreq / freq > MAX_JUMP_RATIO)) {
        // ignore this frame
      } else {
        smoothedFreq = smoothedFreq == null ? freq : (smoothedFreq * (1 - SMOOTH_ALPHA) + freq * SMOOTH_ALPHA);

        const midi = freqToMidi(smoothedFreq);
        const name = midiToNoteName(midi);
        const ref = midiToFreq(midi);
        const cents = centsOff(smoothedFreq, ref);

        noteEl.textContent = name;
        freqEl.textContent = smoothedFreq.toFixed(2);
        centsEl.textContent = (cents >= 0 ? "+" : "") + cents.toFixed(1);
      }
    } else {
      // keep RMS/clarity shown, but clear note if too unstable
      noteEl.textContent = "â€”";
      freqEl.textContent = "â€”";
      centsEl.textContent = "â€”";
      smoothedFreq = null;
    }

    rafId = requestAnimationFrame(loop);
  }

  function stop() {
    running = false;
    btn.textContent = "ğŸ¤ ×”×ª×—×œ";
    statusEl.textContent = "×œ× ×¤×¢×™×œ";

    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;

    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = null;

    if (audioCtx) audioCtx.close();
    audioCtx = null;

    analyser = null;
    smoothedFreq = null;

    noteEl.textContent = "â€”";
    freqEl.textContent = "â€”";
    centsEl.textContent = "â€”";
    clarityEl.textContent = "â€”";
    rmsEl.textContent = "â€”";
  }

  // --- Pitch detection via autocorrelation ---
  // Returns: {freq, clarity, rms}
  function detectPitchAutocorr(signal, sampleRate) {
  // Remove DC
  let mean = 0;
  for (let i = 0; i < signal.length; i++) mean += signal[i];
  mean /= signal.length;

  // RMS
  let rms = 0;
  for (let i = 0; i < signal.length; i++) {
    const v = signal[i] - mean;
    rms += v * v;
  }
  rms = Math.sqrt(rms / signal.length);
  if (rms < RMS_GATE) return { freq: null, clarity: 0, rms };

  const n = signal.length;
  const corr = new Float32Array(n);

  for (let lag = 0; lag < n; lag++) {
    let sum = 0;
    for (let i = 0; i < n - lag; i++) {
      const a = signal[i] - mean;
      const b = signal[i + lag] - mean;
      sum += a * b;
    }
    corr[lag] = sum;
  }

  // Important: NEVER pick lag=0 as the peak.
  // Find the first "valley" after the initial drop, then search for a peak after it.
  let lag = 1;
  while (lag < n - 1 && corr[lag] > corr[lag + 1]) lag++; // descend to valley

  let maxLag = -1;
  let maxVal = -Infinity;
  for (let l = lag; l < n; l++) {
    if (corr[l] > maxVal) {
      maxVal = corr[l];
      maxLag = l;
    }
  }
  if (maxLag <= 0) return { freq: null, clarity: 0, rms };

  const refinedLag = parabolicPeak(corr, maxLag);
  const freq = sampleRate / refinedLag;

  // clarity: peak relative to lag0 energy
  const clarity = clamp01(maxVal / (corr[0] || 1));

  if (freq < 50 || freq > 2000) return { freq: null, clarity: 0, rms };
  return { freq, clarity, rms };
}

    // find where correlation starts descending then later peaks
    let d = 0;
    while (d < n - 1 && corr[d + 1] > corr[d]) d++;

    let maxLag = -1;
    let maxVal = -Infinity;
    for (let lag = d; lag < n; lag++) {
      if (corr[lag] > maxVal) { maxVal = corr[lag]; maxLag = lag; }
    }

    if (maxLag <= 0) return { freq: null, clarity: 0, rms };

    const refinedLag = parabolicPeak(corr, maxLag);
    const freq = sampleRate / refinedLag;

    // clarity ~ peak relative to lag0 energy
    const clarity = clamp01(maxVal / (corr[0] || 1));

    // Typical range for voice/instruments; tweak if needed
    if (freq < 50 || freq > 2000) return { freq: null, clarity: 0, rms };

    return { freq, clarity, rms };
  }

  function parabolicPeak(arr, i) {
    const i0 = i > 0 ? i - 1 : i;
    const i2 = i < arr.length - 1 ? i + 1 : i;
    if (i0 === i || i2 === i) return i;

    const y0 = arr[i0], y1 = arr[i], y2 = arr[i2];
    const denom = (y0 - 2*y1 + y2);
    if (denom === 0) return i;

    const delta = 0.5 * (y0 - y2) / denom;
    return i + delta;
  }

  // --- Note helpers ---
  function freqToMidi(f) { return Math.round(69 + 12 * Math.log2(f / 440)); }
  function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }
  function midiToNoteName(m) {
    const name = NOTE_NAMES[(m % 12 + 12) % 12];
    const octave = Math.floor(m / 12) - 1; // MIDI 60 = C4
    return `${name}${octave}`;
  }
  function centsOff(f, ref) { return 1200 * Math.log2(f / ref); }
  function clamp01(x) { return Math.max(0, Math.min(1, x)); }

  window.addEventListener("pagehide", stop);
})();
</script>
</body>
</html>
